### 1. JavaScript操作数组的方法有哪些？
`push()
pop()
shift()
unshift()
sort()
reverse()
splice()
concat()
join()
map()
filter()
some()
reduce()
isArray()
findIndex()`
``
### 2. JavaScript对数据类的检测方式有哪些？
`typeof() 
`instanceof()`
`constructor()`
`object.prototype.toString().call()`                     
### 3. 说一下闭包，闭包有什么缺点？
*闭包是有权限访问 '其他函数作用域的局部变量' 的函数*
1. `由于在Js中，变量的作用域属于函数作用域，函数执行后作用域就会被清理，内存也随之收回。但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数(闭包),便拥有了访问上级作用域中变量的权限。`
特点：可以重复利用变量，不会污染全局。一直保存在内存中。
缺点：闭包较多的时候，会消耗内存导致页面性能下降，在IE浏览器中可能会导致内存泄漏。
使用场景：防抖，节流
### 4. 哪些操作会导致内存泄漏？
`Js已经分配内存地址的对象,但是由于长时间没有释放或者没办法清除,造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。(不能回收)`
因素：
1. 意外的全局变量
2. 一些未清空的定时器
3. 过度的闭包
4. 一些引用元素没有被清除
### 5. 事件委托(也叫事件代理)是什么？
*利用事件冒泡的机制来实现，也就是把子元素的事件绑定到父元素的身上*，如果子元素阻止了事件冒泡，那么委托也就不成立
阻止事件冒泡：event.stopPropagation()
addEventListener('click',函数名,true/false),默认是false(事件冒泡),true(事件捕获)
优点：提高性能,减少事件的绑定，也就减少了内存的占用
### 6. 基本数据类型和引用数据类型的区别？
1. 基本数据类型：*String Number Boolean undefined null*
保存在==栈内存==中,保存的就是一个具体的值
2. 引用数据类型(复杂数据类型)：*Object Array Function*
保存在==堆内存==中,声明一个引用类型的变量,保存的是引用类型数据的地址
### 7. 说一下原型链
原型是一个普通对象,它是为构造函数的实例共享属性和方法。所有实例中引用的原型都是同一个对象使用prototype可以把方法挂在原型上，内存值保存一份。
__*proto__ 可以理解为指针,实例对象中的属性,指向了构造函数的原型(prototype)
一个实例对象在调用属性和方法的时候，会依次从实例本身、构造函数原型、原型的原型上去查找,这样的像链条一样的查找过程叫原型链*。

### ​8. new操作符做了什么？
1. 先创建一个对象
2. 把空对象和构造函数通过原型链进行链接
3. 把构造函数的this绑定到新的空对象身上
4. 根据构造函数返回的类型推断,如果是值类型,则返回对象,如果是引用类型,就要返回这个引用类型。
### 9. JavaScript是如何实现继承的？
1. 原型链继承
2. 借用构造函数继承
3. 组合式继承
4. Es6的class继承
### 10. JavaScript的设计原理
Js引擎 运行上下文 调用栈 事件循环 回调
### 11. JavaScript关于this指向的问题
1. 全局对象中的this指向
   指向是window
2. 全局作用域或者普通函数中的this
   指向全局window
3. 非箭头函数的情况下,this永远指向最后调用它的那个对象
4. new 关键词改变了this的指向
5. call,apply,bind 可以改变this指向,不是箭头函数
6. 箭头函数中的this
    它的指向在定义的时候就已经确定了,箭头函数它没有this,看外层是否有函数,有就是外层函数的this,没有就是window
7. 匿名函数中的this
    永远指向window,匿名函数的执行环境具有全局性,因此this指向window
### 12. setTimeout和setInterval最小执行时间
HTML5规定内容:
setTimeout最小是4ms
setInterval最小是10ms
### 13. call,appply,bind三者有什么区别
都是改变this指向和函数的调用,call和apply的功能类似,只是传参的方法不同
*call方法传的是一个参数列表*
*apply传递的是一个数组*
*bind传参后不会立即执行,会返回一个改变this指向的函数*,这个函数还是可以传参的,bind()()
call方法的性能要比apply好一些,所以call用的更多一点
### ​14. 如何实现一个深拷贝
深拷贝就是完全拷贝一份新的对象,会在堆内存中开辟新的空间,拷贝的对象被修改后,原对象不受影响，主要针对引用类型
`1. 拓展运算符`
==缺点: 只能拷贝第一层==
`2. JSON.parse(JSON.stringify())`
==缺点: 不会拷贝内部函数==
`3. 利用递归函数实现`
### 15. 说一下事件循环
Js是一个单线程的脚本语言
主线程 执行栈 任务队列 宏任务 微任务
`主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务，全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环`
### 16. ajax是什么？如何实现？
`在不重新加载整个网页的前提下，与服务器交换数据并更新内容，通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过Js操作DOM更新页面`
### 17. get和post有什么区别？
1. get参数会放在url上，安全性较差。post是放在body中
2. get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据
3. get请求时会被缓存，post请求不会缓存
4. get请求会被保存在浏览器历史记录中，post不会
5. get请求只能进行url编码，post请求支持很多种
### 18.  promise的内部原理是什么？它的优缺点是什么？
		Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果
		promise主要就是解决回调地狱的问题,回调地狱的原因是异步任务比较多，存在相互依赖的问题,然而代码的可读性差，可维护性差。
		有三种状态：pending(初始状态) fulfilled(成功状态) rejected(失败状态)
		状态改变时只有两种情况：
			pending--->fulfilled; pending-->rejected 一旦发生,状态就会凝固,不会再变。
		首先时我们无法取消promise,一旦创建他就会立即执行,不能中途取消。
		如果不设置回调，promise内部抛出的错误就无法反馈到外部
		若当前处于pending状态时,无法得知目前在那个阶段
		原理：
		     构造一个Promise实例,实例需要传递函数的参数,这个函数有两个形参,分别是函数类型
		     一个resolve,一个reject
### 19. Promise和async await有什么区别？
	1. 都是处理异步请求的方式,Promise是Es6的语法,async await 是Es7的语法
	2. async await是基于Promise实现的，都是非阻塞性的
	优缺点：
		1. promise是返回对象要用then，catch方法去处理和捕获异常，书写方式是链式,async await是try catch 进行捕获异常
		2. async await 看起来简洁，使得异步代码看起来像同步代码，只有await的代码执行完毕后才会执行后面的代码。
		3. promise.then()的方式会出现请求还没返回，就执行了后面的操作
### 20. 浏览器的储存方式有哪些？
1. cookie
2. localStorage
H5,以键值对的形式的存储,永久存储
3. sessionStorage
当前页面关闭后就会立刻清理，会话级别的存储方式
4. indexedDB
H5标准的储存方式，以键值对进行储存，可以快速读取，适合Web场景

### 21. 介绍下token
token: 验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作得到的字符串
1. 存localStorage中，后期每次请求接口都需要把它当作一个字段传给后台
2. 存cookie中，会自动发送，缺点是不能跨域
登录流程：
1. 客户端用账号密码请求登录
2. 服务端收到请求后，需要去验证账号密码
3. 验证成功后，服务端签发一个token,把它发给客户端
4. 客户端收到token后保存起来，可以放在localStorage或者cookie
5. 客户端后续的请求，都需要携带这个token
6. 服务器收到请求，去验证客户端的token,验证成功返回数据给客户端。
### 22. 页面渲染的过程是怎样的？
1. DNS解析
2. 建立TCP请求
3. 发送HTTP请求
4. 服务器处理请求
5. 渲染页面
		浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树
		再把CSS解析成CSSDOM，把DOM和CSSDOM合并为渲染树，将渲染树的每个节点渲染(绘制)到屏幕上
### 23. JWT
JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之问安全的把信息作为JSON对象传输信息、授权
JWT的认证流程
1. 前端把账号密码发送给后端的接口
2. 后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT (token)。
3. 前端每日请求时都会把了WT放 在HTTP请求头的Authorization宇段内
4. 后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
5. 验证通过后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
简洁、包含性、因为Token 是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。
### 24. HTTP协议对丁的协议头和请求头有什么？
1. 请求头信息：
	Accept: 浏览器告诉服务器所支持的数据类型
	Host: 浏览器告诉服务器访问的主机
	Referer: 浏览器告诉服务器我是从哪里来的(防盗链)
	User-Agent: 浏览器类型、版本信息
	Date: 浏览器告诉服务器我是什么时候访问的
	Connection: 连接方式
	Cookie
	X-Request-With: 请求方式
2. 响应头消息
	Location: 告诉浏览器去找谁
	Server: 告诉浏览器服务器的类型
	Content-Type: 告诉浏览器返回的数据类型
	Refresh: 控制的定时刷新
### 25. 说一下浏览器的缓存策略
强缓存(本地缓存) 弱缓存(协商缓存)
强缓存：不发起请求，直接使用缓存里的内容，浏览器把Js,css,image等存到内存中，下次用户访问直接从内存中取，提高性能
协商缓存：需要像后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容。
强缓存的触发：
	HTTP1.0：时间戳响应头
	HTTP1.1: Cache-Control响应头
协商缓存的触发：
	HTTP1.0: 请求头: if-modified-since 响应头：last-modified
	HTTP1.1: 请求头: if-none-match 响应头：Etag
### 26. 说一下什么是同源策略？
http:// www.baidu.com :8080      /index/vue.js
协议    域名                   端口号 
如果两个URL 的[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)、[端口](https://developer.mozilla.org/zh-CN/docs/Glossary/Port)和[主机](https://developer.mozilla.org/zh-CN/docs/Glossary/Host)都相同的话，则这两个 URL 是同源的。
有其中一个不一样会产生跨域，img，link，script允许跨域加载资源的标签。
JSONP 
CORS：后端设置`Access-Control-Allow-Origin`响应头为目标`host`
Proxy :  通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域

vue.config.js
```
 proxy: {
            '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
                target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
                changeOrigin: true, //是否跨域
                pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
                    '^/api': "" 
                }
            }
        }
```

通过axios发送请求_配置请求的根路径
```
axios.defaults.baseURL = '/api'
```