### 1. JavaScript操作数组的方法有哪些？
`push()
pop()
shift()
unshift()
sort()
reverse()
splice()
concat()
join()
map()
filter()
some()
reduce()
isArray()
findIndex()`
``
### 2. JavaScript对数据类的检测方式有哪些？
`typeof() 
`instanceof()`
`constructor()`
`object.prototype.toString().call()`                     
### 3. 说一下闭包，闭包有什么缺点？
*闭包是有权限访问 '其他函数作用域的局部变量' 的函数*
1. `由于在Js中，变量的作用域属于函数作用域，函数执行后作用域就会被清理，内存也随之收回。但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数(闭包),便拥有了访问上级作用域中变量的权限。`
特点：可以重复利用变量，不会污染全局。一直保存在内存中。
缺点：闭包较多的时候，会消耗内存导致页面性能下降，在IE浏览器中可能会导致内存泄漏。
使用场景：防抖，节流
### 4. 哪些操作会导致内存泄漏？
`Js已经分配内存地址的对象,但是由于长时间没有释放或者没办法清除,造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。(不能回收)`
因素：
1. 意外的全局变量
2. 一些未清空的定时器
3. 过度的闭包
4. 一些引用元素没有被清除
### 5. 事件委托(也叫事件代理)是什么？
*利用事件冒泡的机制来实现，也就是把子元素的事件绑定到父元素的身上*，如果子元素阻止了事件冒泡，那么委托也就不成立
阻止事件冒泡：event.stopPropagation()
addEventListener('click',函数名,true/false),默认是false(事件冒泡),true(事件捕获)
优点：提高性能,减少事件的绑定，也就减少了内存的占用
### 6. 基本数据类型和引用数据类型的区别？
1. 基本数据类型：*String Number Boolean undefined null*
保存在==栈内存==中,保存的就是一个具体的值
2. 引用数据类型(复杂数据类型)：*Object Array Function*
保存在==堆内存==中,声明一个引用类型的变量,保存的是引用类型数据的地址
### 7. 说一下原型链
原型是一个普通对象,它是为构造函数的实例共享属性和方法。所有实例中引用的原型都是同一个对象使用prototype可以把方法挂在原型上，内存值保存一份。
__*proto__ 可以理解为指针,实例对象中的属性,指向了构造函数的原型(prototype)
一个实例对象在调用属性和方法的时候，会依次从实例本身、构造函数原型、原型的原型上去查找,这样的像链条一样的查找过程叫原型链*。

### ​8. new操作符做了什么？
1. 先创建一个对象
2. 把空对象和构造函数通过原型链进行链接
3. 把构造函数的this绑定到新的空对象身上
4. 根据构造函数返回的类型推断,如果是值类型,则返回对象,如果是引用类型,就要返回这个引用类型。
### 9. JavaScript是如何实现继承的？
1. 原型链继承
2. 借用构造函数继承
3. 组合式继承
4. Es6的class继承
### 10. JavaScript的设计原理
Js引擎 运行上下文 调用栈 事件循环 回调
### 11. JavaScript关于this指向的问题
1. 全局对象中的this指向
   指向是window
2. 全局作用域或者普通函数中的this
   指向全局window
3. 非箭头函数的情况下,this永远指向最后调用它的那个对象
4. new 关键词改变了this的指向
5. call,apply,bind 可以改变this指向,不是箭头函数
6. 箭头函数中的this
    它的指向在定义的时候就已经确定了,箭头函数它没有this,看外层是否有函数,有就是外层函数的this,没有就是window
7. 匿名函数中的this
    永远指向window,匿名函数的执行环境具有全局性,因此this指向window
### 12. setTimeout和setInterval最小执行时间
HTML5规定内容:
setTimeout最小是4ms
setInterval最小是10ms
### 13. call,appply,bind三者有什么区别
都是改变this指向和函数的调用,call和apply的功能类似,只是传参的方法不同
*call方法传的是一个参数列表*
*apply传递的是一个数组*
*bind传参后不会立即执行,会返回一个改变this指向的函数*,这个函数还是可以传参的,bind()()
call方法的性能要比apply好一些,所以call用的更多一点
### ​14. 如何实现一个深拷贝
深拷贝就是完全拷贝一份新的对象,会在堆内存中开辟新的空间,拷贝的对象被修改后,原对象不受影响，主要针对引用类型
`1. 拓展运算符`
==缺点: 只能拷贝第一层==
`2. JSON.parse(JSON.stringify())`
==缺点: 不会拷贝内部函数==
`3. 利用递归函数实现`
### 15. 说一下事件循环
Js是一个单线程的脚本语言
主线程 执行栈 任务队列 宏任务 微任务
`主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务，全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环`
### 16. ajax是什么？如何实现？
`在不重新加载整个网页的前提下，与服务器交换数据并更新内容，通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过Js操作DOM更新页面`
### 17. get和post有什么区别？
1. get参数会放在url上，安全性较差。post是放在body中
2. get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据
3. get请求时会被缓存，post请求不会缓存
4. get请求会被保存在浏览器历史记录中，post不会
5. get请求只能进行url编码，post请求支持很多种
### 18.  promise的内部原理是什么？它的优缺点是什么？
		Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果
		promise主要就是解决回调地狱的问题,回调地狱的原因是异步任务比较多，存在相互依赖的问题,然而代码的可读性差，可维护性差。
		有三种状态：pending(初始状态) fulfilled(成功状态) rejected(失败状态)
		状态改变时只有两种情况：
			pending--->fulfilled; pending-->rejected 一旦发生,状态就会凝固,不会再变。
		首先时我们无法取消promise,一旦创建他就会立即执行,不能中途取消。
		如果不设置回调，promise内部抛出的错误就无法反馈到外部
		若当前处于pending状态时,无法得知目前在那个阶段
		原理：
		     构造一个Promise实例,实例需要传递函数的参数,这个函数有两个形参,分别是函数类型
		     一个resolve,一个reject
### 19. Promise和async await有什么区别？
	1. 都是处理异步请求的方式,Promise是Es6的语法,async await 是Es7的语法
	2. async await是基于Promise实现的，都是非阻塞性的
	优缺点：
		1. promise是返回对象要用then，catch方法去处理和捕获异常，书写方式是链式,async await是try catch 进行捕获异常
		2. async await 看起来简洁，使得异步代码看起来像同步代码，只有await的代码执行完毕后才会执行后面的代码。
		3. promise.then()的方式会出现请求还没返回，就执行了后面的操作
### 20. 浏览器的储存方式有哪些？
1. cookie
2. localStorage
H5,以键值对的形式的存储,永久存储
3. sessionStorage
当前页面关闭后就会立刻清理，会话级别的存储方式
4. indexedDB
H5标准的储存方式，以键值对进行储存，可以快速读取，适合Web场景

### 21. token
token: 验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作得到的字符串
1. 存localStorage中，后期每次请求接口都需要把它当作一个字段传给后台
2. 存cookie中，会自动发送，缺点是不能跨域