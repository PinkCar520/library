### 1. vue3的性能为什么比vue2好？ ⭐⭐⭐⭐⭐
1. diff算法的优化
2. 静态提升
3. 事件监听缓存
### 2. vue3为什么使用proxy? ⭐⭐⭐⭐⭐
1. proxy可以代理整个对象，defineproperty只代理对象上的某个属性
### 3. v-if和v-show的区别？⭐⭐
	1. v-if 是真正的条件渲染,因为它会确保在切换过程中,条件块内的事件监听器和子组件适当地被销毁和重建通过
	2. v-show 是简单的基于css切换,通过display:none来实现的
	总结: 一般来说v-if有更高的切换开销,而v-show有更高的初始渲染开销,如果是运行条件很少改变的场景下使用v-if比较好,切换频繁的场景下使用v-show比较好。
### 4. 如何理解MVVM? ⭐⭐⭐⭐⭐
	model(模型->内容的数据访问型) view(视图层->用户界面<html/css>) viewModel(暴露公共属性和命令->绑定器在view层和model层之间通信)
	1. MVVM是一种设计思想,核心是提供对View和ViewModel的双向数据绑定:
		当数据改变的时候,viewModel能监听到数据的变化,自动更新视图
		当用户操作视图的时候,viewModel也可以监听到视图的变化,然后通知数据进行改动,这就实现了双向数据绑定。
	2. viewModel通过双向绑定把View和Model连接起来,View 和 Model 之间的同步工作完全是自动的,无需人为干涉,所以我们只需要关注业务逻辑即可,不需要操作DOM,同时也不需要关于数据的状态问题。
	3. MVVM实现了页面业务逻辑和渲染之间的解耦,也实现了数据与视图的解耦。
	优点：便于维护、低耦合
	
### 5. v-for的key值的作用是什么？⭐⭐
	主要用在vue的虚拟DOM算法中,在新旧nodes对比时辨识VNodes,相当于唯一标识ID
	1. vue使用'key'来跟踪每个元素的身份,这样在数组发生变化时,Vue可以更高效地识别变化的部分，并且仅重新渲染需要更新的元素，从而减少了DOM操作的开销，提高了性能。
	2. 维护组件状态时,当数组中的元素位置发生变化时,可能会出现不正确的渲染结果。
	3. 通常在选择'key'值时,应该使用具有稳定唯一性的值,比如元素的唯一ID,数据库主键等,避免使用index,因为这样可能会导致不必要的重新渲染
	

### 6. 谈一下你对vue生命周期的理解 ⭐⭐⭐
	vue的生命周期是指Vue实例从创建、挂载、更新到销毁的一系列流程,它允许开发者在不同的阶段插入自定义的代码逻辑,vue的生命周期可以分为以下几个阶段
	1. 创建阶段
		beforeCreate: 在实例初始化之后,进行数据侦听和事件、侦听器的配置之前同步调用。
		created：在实例创建完成后被立即调用,此时已经完成了,但是还未开始DOM的挂载。
	2. 挂载阶段
		beforeMount：在挂载之前被调用,在这个阶段模板编译完成,但是还未把生成的DOM渲染到页面上
		mounted：实例被挂载后调用,此时Vue实例已经把生成的DOM渲染到页面
		应用场景：可以执行DOM操作/执行异步请求。
	3. 更新阶段
		beforeUpdate：在数据发生改变后,DOM被更新之前被调用。适合现有DOM将要被更新之前访问,比如移除手动添加的事件监听器
		updated：在数据更改导致的虚拟DOM重新渲染和更新完毕之后调用。避免在这个期间更改状态。不会保证所有的子组件也都被重新渲染,整个视图都渲染完毕的话,可以在 `updated` 里使用nextTick
	4. 销毁阶段
		beforeDestroy：在实例销毁之前被调用
		应用场景：解绑事件,取消定时器等。
		destroyed：实例销毁后调用,对应vue实例的所有指令都被解绑,所有的事件监听器被移除,所有的子实例也都被销毁。
	activated: 被keep-alive缓存的组件激活时调用
	deactivated: 被keep-alive缓存的组件失活时调用
### 7. vue的修饰符有哪些？⭐

### 8 . vue如何进行组件通信？ ⭐⭐⭐⭐
	1. Props/父子组件通信：
		通过在父组件中使用属性(props)来向子组件传递数据。子组件可以通过`props`选项来接收这些属性。实现单项数据流的基本方法,子组件无法直接修改父组件的属性。
	2. 自定义事件/子父组件通信：
		子组件->可以通过`$emit`方法触发自定义事件,并将需要传递的数据作为参数传递给父组件。
		父组件->可以使用v-on或@指令来监听子组件触发的事件,并在事件处理函数中获取传递的数据。
	3. Vuex/集中式状态管理：
		用于在多个组件之间共享状态,Vuex将状态集中储存在一个全局的状态树中,组件可以通过this.$store.state来访问状态,同时也可以使用mutations来修改状态。
	4. Provide/Inject
		父组件可以通过provide选项提供数据,子组件可以通过inject选项来注入这些数据。适用于祖先组件->后代组件传递数据,但是不适合在非直接父子关系的组件之间使用
	5.
### 9. keep-alive是什么？使用方式？ ⭐⭐⭐
`Keep-alive是Vue提供的内置组件，用于缓存和复用组件实例，对于频繁切换组件或在组件内有大量状态需要维护时，可以有效提升性能。`
应用场景:
1. `当一个组件被包裹在Keep-alive标签内部时，该组件的实例将被缓存，而不是每次都重新创建一个新的组件实例，这对于一些需要保持状态的组件(表单数据或滚动位置)非常有用`
### 10. vue路由怎么传参？ ⭐⭐⭐⭐

### 11. vue路由的hash模式和history模式有什么区别？ ⭐⭐⭐⭐
Hash模式
1. `以#为基础，浏览器不会向服务器发送请求，只会解释hash的变化`。
应用场景：
`适用于单页应用(SPA),不需要服务器配置。`

History模式:
1. `通过HTML5的`  `history.pushState` 和 `history.replaceState`` API,在URL发生变化时，浏览器会向服务器请求对应资源`
应用场景:
`适用于提升 SEO 的优化和需要 服务器配置 来支持URL的变化`

### 12. vue路由拦截是怎么实现的？⭐⭐⭐
**beforeEach：** `在每个路由导航之前执行。用于进行权限验证、登录状态检查等。如果未通过验证，可以跳转登录页面`。
**afterEach：** `在每个路由导航之后执行。通常用于埋点统计等操作，不会影响导航本身。``
**beforeRouteEnter：** `在进入路由之前被调用。适用于获取路由组件内部的数据，如从服务器获取数据后再进入路由。`
**beforeRouteUpdate：** `在当前路由复用时调用，如在同一路由不同参数间切换。 
**beforeRouteLeave：** `在离开当前路由之前被调用。用于显示确认提示框，或保存未提交的表单数据等。
### 13. 说一下vue的动态路由 ⭐⭐⭐⭐
### 14. 如何解决刷新后二次加载路由 ⭐⭐⭐
### 15.vue刷新数据丢失如何解决？ ⭐⭐⭐
### 16. computed和watch的区别 ⭐⭐⭐
computed
1. 支持缓存,不支持异步操作。
2. 基于响应式数据的衍生属性,只有依赖的数据变化时才会重新计算。
3. 

### 17. vuex的主要应用场景以及使用方式 ⭐⭐⭐
  
Vuex 是 Vue.js 的官方状态管理库，用于管理应用程序中的共享状态。主要应用场景包括：

1. **大型应用程序：** 在大型应用中，组件之间可能需要共享许多状态（如用户信息、购物车状态等）。使用 Vuex 可以更方便地集中管理这些共享状态，避免状态分散在不同组件中导致难以维护的情况。
    
2. **跨组件通信：** 如果多个组件需要共享数据或进行通信，Vuex 提供了一个集中的地方来存储和更新这些数据，使得跨组件通信更加清晰和可控。
    
3. **异步操作：** Vuex 也适用于处理异步操作，比如发送网络请求或操作后端数据。您可以在 Vuex 中定义 actions 来触发异步操作，确保状态的变化是可追踪的。
### 18. vue的响应式原理是什么？⭐⭐⭐
响应式是vue的特性之一。
Vue2.x中是通过Object.defineProperty()实现的
`Vue3使用了 JavaScript 中的 Proxy 对象来实现响应式。Proxy 可以拦截对象的操作，包括属性的读取、赋值、删除等操作，从而实现对数据的劫持和观察。`
### 18. vue的双向数据绑定是什么 ⭐⭐⭐
`双向数据绑定通常是指我们使用的v-model指令的实现，是vue的一个特性，也可以说是一个input事件和value的语法糖。vue通过v-model指令为组件添加上input事件处理和value属性的赋值`
### 19. 了解diff算法和虚拟DOM吗？ ⭐⭐⭐⭐
**虚拟 DOM（Virtual DOM）：** `虚拟 DOM 是一种用 JavaScript 对象表示真实 DOM 结构的技术。它允许框架在更新视图时，先在虚拟 DOM 上进行操作，然后通过比较新旧虚拟 DOM 的差异来最小化对真实 DOM 的操作。这样可以提高性能，因为操作虚拟 DOM 的成本要比操作真实 DOM 低得多。Vue 和 React 都使用了虚拟 DOM 来优化视图更新。`

**Diff 算法：** `Diff 算法是用于比较两个树结构的算法，常用于比较虚拟 DOM 和确定最小化的 DOM 更新。当数据发生变化时，Diff 算法会比较新旧虚拟 DOM 树，找出差异，然后在真实 DOM 中应用这些差异。Diff 算法的目标是尽量减少 DOM 操作的数量，从而提高性能。`

**Diff 算法的基本思想是：**
1. 比较两棵树的根节点，如果不同，则替换根节点及其子树。
2. 对比新旧节点的类型，如果类型不同，则替换节点。
3. 对比节点的属性和内容，更新有变化的部分。
4. 递归比较子节点，找出子节点之间的差异。
通过这种方式，Diff 算法可以高效地确定需要更新的部分，从而最小化了 DOM 操作的开销
###
###
###
###