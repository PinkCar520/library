### 1. vue3的性能为什么比vue2好？ ⭐⭐⭐⭐⭐
1. diff算法的优化
2. 静态提升
3. 事件监听缓存
### 2. vue3为什么使用proxy? ⭐⭐⭐⭐⭐
1. proxy可以代理整个对象，defineproperty只代理对象上的某个属性
### 3. v-if和v-show的区别？⭐⭐
	1. v-if 是真正的条件渲染,因为它会确保在切换过程中,条件块内的事件监听器和子组件适当地被销毁和重建通过
	2. v-show 是简单的基于css切换,通过display:none来实现的
	总结: 一般来说v-if有更高的切换开销,而v-show有更高的初始渲染开销,如果是运行条件很少改变的场景下使用v-if比较好,切换频繁的场景下使用v-show比较好。
### 4. 如何理解MVVM? ⭐⭐⭐⭐⭐
	model(模型->内容的数据访问型) view(视图层->用户界面<html/css>) viewModel(暴露公共属性和命令->绑定器在view层和model层之间通信)
	1. MVVM是一种设计思想,核心是提供对View和ViewModel的双向数据绑定:
		当数据改变的时候,viewModel能监听到数据的变化,自动更新视图
		当用户操作视图的时候,viewModel也可以监听到视图的变化,然后通知数据进行改动,这就实现了双向数据绑定。
	2. viewModel通过双向绑定把View和Model连接起来,View 和 Model 之间的同步工作完全是自动的,无需人为干涉,所以我们只需要关注业务逻辑即可,不需要操作DOM,同时也不需要关于数据的状态问题。
	3. MVVM实现了页面业务逻辑和渲染之间的解耦,也实现了数据与视图的解耦。
	优点：便于维护、低耦合
	
### 5. v-for的key值的作用是什么？⭐⭐
	主要用在vue的虚拟DOM算法中,在新旧nodes对比时辨识VNodes,相当于唯一标识ID
	1. vue使用'key'来跟踪每个元素的身份,这样在数组发生变化时,Vue可以更高效地识别变化的部分，并且仅重新渲染需要更新的元素，从而减少了DOM操作的开销，提高了性能。
	2. 维护组件状态时,当数组中的元素位置发生变化时,可能会出现不正确的渲染结果。
	3. 通常在选择'key'值时,应该使用具有稳定唯一性的值,比如元素的唯一ID,数据库主键等,避免使用index,因为这样可能会导致不必要的重新渲染
	

### 6. 谈一下你对vue生命周期的理解 ⭐⭐⭐
	vue的生命周期是指Vue实例从创建、挂载、更新到销毁的一系列流程,它允许开发者在不同的阶段插入自定义的代码逻辑,vue的生命周期可以分为以下几个阶段
	1. 创建阶段
		beforeCreate: 在实例初始化之后,进行数据侦听和事件、侦听器的配置之前同步调用。
		created：在实例创建完成后被立即调用,此时已经完成了,但是还未开始DOM的挂载。
	2. 挂载阶段
		beforeMount：在挂载之前被调用,在这个阶段模板编译完成,但是还未把生成的DOM渲染到页面上
		mounted：实例被挂载后调用,此时Vue实例已经把生成的DOM渲染到页面
		应用场景：可以执行DOM操作/执行异步请求。
	3. 更新阶段
		beforeUpdate：在数据发生改变后,DOM被更新之前被调用。适合现有DOM将要被更新之前访问,比如移除手动添加的事件监听器
		updated：在数据更改导致的虚拟DOM重新渲染和更新完毕之后调用。避免在这个期间更改状态。不会保证所有的子组件也都被重新渲染,整个视图都渲染完毕的话,可以在 `updated` 里使用nextTick
	4. 销毁阶段
		beforeDestroy：在实例销毁之前被调用
		应用场景：解绑事件,取消定时器等。
		destroyed：实例销毁后调用,对应vue实例的所有指令都被解绑,所有的事件监听器被移除,所有的子实例也都被销毁。
	activated: 被keep-alive缓存的组件激活时调用
	deactivated: 被keep-alive缓存的组件失活时调用
### 7. vue的修饰符有哪些？⭐

### 8 . vue如何进行组件通信？ ⭐⭐⭐⭐
	1. Props/父子组件通信：
		通过在父组件中使用属性(props)来向子组件传递数据。子组件可以通过`props`选项来接收这些属性。实现单项数据流的基本方法,子组件无法直接修改父组件的属性。
	2. 自定义事件/子父组件通信：
		子组件->可以通过`$emit`方法触发自定义事件,并将需要传递的数据作为参数传递给父组件。
		父组件->可以使用v-on或@指令来监听子组件触发的事件,并在事件处理函数中获取传递的数据。
	3. Vuex/集中式状态管理：
		用于在多个组件之间共享状态,Vuex将状态集中储存在一个全局的状态树中,组件可以通过this.$store.state来访问状态,同时也可以使用mutations来修改状态。
	4. Provide/Inject
		父组件可以通过provide选项提供数据,子组件可以通过inject选项来注入这些数据。适用于祖先组件->后代组件传递数据,但是不适合在非直接父子关系的组件之间使用
	5.
### 9. keep-alive是什么？使用方式？ ⭐⭐⭐

### 10. vue路由怎么传参？ ⭐⭐⭐⭐
### 11. vue路由的hash模式和history模式有什么区别？ ⭐⭐⭐⭐
Hash模式
1. `以#为基础，浏览器不会向服务器发送请求，只会解释hash的变化`
应用场景：
`适用于单页应用(SPA),不需要服务器配置。`
History模式:
1. 

### 12. vue路由拦截是怎么实现的？⭐⭐⭐
**beforeEach：** `在每个路由导航之前执行。用于进行权限验证、登录状态检查等。如果未通过验证，可以跳转登录页面`。
**afterEach：** `在每个路由导航之后执行。通常用于埋点统计等操作，不会影响导航本身。``
**beforeRouteEnter：** `在进入路由之前被调用。适用于获取路由组件内部的数据，如从服务器获取数据后再进入路由。`
**beforeRouteUpdate：** `在当前路由复用时调用，如在同一路由不同参数间切换。 
**beforeRouteLeave：** `在离开当前路由之前被调用。用于显示确认提示框，或保存未提交的表单数据等。
### 13. 说一下vue的动态路由 ⭐⭐⭐⭐
### 14. 如何解决刷新后二次加载路由 ⭐⭐⭐
### 15.vue刷新数据丢失如何解决？ ⭐⭐⭐
### 16. computed和watch的区别 ⭐⭐⭐
computed
1. 支持缓存,不支持异步操作。
2. 基于响应式数据的衍生属性,只有依赖的数据变化时才会重新计算。
3. 

### 17. vuex的主要应用场景以及使用方式 ⭐⭐⭐
### 18. vue的双向数据绑定原理是什么 ⭐⭐⭐
### 19. 了解diff算法和虚拟DOM吗？ ⭐⭐⭐⭐
###
###
###
###