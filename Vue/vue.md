### 1. vue3的性能为什么比vue2好？ ⭐⭐⭐⭐⭐
**使用 Proxy 替代 Object.defineProperty：**` Vue 3 在响应式系统中采用了 Proxy 对象来替代 Vue 2 中使用的 `Object.defineProperty`。Proxy 提供了更强大的劫持能力，能够捕获更多类型的操作，从而使得 Vue 3 的响应式系统更高效、精确，能够更准确地追踪对象和数组的变化。这导致在性能方面的提升，特别是在处理大型对象和深层嵌套对象时`。
**编译优化：**` Vue 3 引入了基于模块的编译，允许将组件的模板进行静态分析，从而进行更精细的优化和减少运行时的开销。这使得 Vue 3 在渲染组件时能够更有效地生成渲染函数，提高了渲染性能。`
**虚拟 DOM 优化：** `Vue 3 对虚拟 DOM 进行了一些优化，使用了更高效的算法来减少虚拟 DOM 的创建和比对成本。Vue 3 的虚拟 DOM 渲染过程更快速，减少了不必要的 DOM 操作，从而提升了性能。`
**Tree-shaking 支持：**` Vue 3 通过使用 ES 模块的方式来组织代码，使得现代打包工具能够更好地进行 Tree-shaking，即消除没有使用的代码，减少了最终生成的包的大小，提升了加载性能。`
### 2. vue3为什么使用proxy? ⭐⭐⭐⭐⭐
**更强大的劫持能力：** `Proxy 允许我们捕获更多种类的操作，包括属性的读取、写入、删除等,直接监听数组的变化。`defineProperty`自身的缺陷需要重写数组方法、增加额外`set`、`delete`方法
**性能优化：** `Proxy 在底层实现上更高效，不需要像 `Object.defineProperty` 那样遍历对象属性来劫持，这导致了 Vue 3 在处理大型对象和数组时性能更好。
### 3. v-if和v-show的区别？⭐⭐
	1. v-if 是真正的条件渲染,因为它会确保在切换过程中,条件块内的事件监听器和子组件适当地被销毁和重建通过
	2. v-show 是简单的基于css切换,通过display:none来实现的
	总结: 一般来说v-if有更高的切换开销,而v-show有更高的初始渲染开销,如果是运行条件很少改变的场景下使用v-if比较好,切换频繁的场景下使用v-show比较好。
### 4. 如何理解MVVM? ⭐⭐⭐⭐⭐
	model(模型->内容的数据访问型) view(视图层->用户界面<html/css>) viewModel(暴露公共属性和命令->绑定器在view层和model层之间通信)
	1. MVVM是一种设计思想,核心是提供对View和ViewModel的双向数据绑定:
		当数据改变的时候,viewModel能监听到数据的变化,自动更新视图
		当用户操作视图的时候,viewModel也可以监听到视图的变化,然后通知数据进行改动,这就实现了双向数据绑定。
	2. viewModel通过双向绑定把View和Model连接起来,View 和 Model 之间的同步工作完全是自动的,无需人为干涉,所以我们只需要关注业务逻辑即可,不需要操作DOM,同时也不需要关于数据的状态问题。
	3. MVVM实现了页面业务逻辑和渲染之间的解耦,也实现了数据与视图的解耦。
	优点：便于维护、低耦合
	
### 5. v-for的key值的作用是什么？⭐⭐
	主要用在vue的虚拟DOM算法中,在新旧nodes对比时辨识VNodes,相当于唯一标识ID
	1. vue使用'key'来跟踪每个元素的身份,这样在数组发生变化时,Vue可以更高效地识别变化的部分，并且仅重新渲染需要更新的元素，从而减少了DOM操作的开销，提高了性能。
	2. 维护组件状态时,当数组中的元素位置发生变化时,可能会出现不正确的渲染结果。
	3. 通常在选择'key'值时,应该使用具有稳定唯一性的值,比如元素的唯一ID,数据库主键等,避免使用index,因为这样可能会导致不必要的重新渲染
	

### 6. 谈一下你对vue生命周期的理解 ⭐⭐⭐
	vue的生命周期是指Vue实例从创建、挂载、更新到销毁的一系列流程,它允许开发者在不同的阶段插入自定义的代码逻辑,vue的生命周期可以分为以下几个阶段
	1. 创建阶段
		beforeCreate: 在实例初始化之后,进行数据侦听和事件、侦听器的配置之前同步调用。
		created：在实例创建完成后被立即调用,此时已经完成了,但是还未开始DOM的挂载。
	2. 挂载阶段
		beforeMount：在挂载之前被调用,在这个阶段模板编译完成,但是还未把生成的DOM渲染到页面上
		mounted：实例被挂载后调用,此时Vue实例已经把生成的DOM渲染到页面
		应用场景：可以执行DOM操作/执行异步请求。
	3. 更新阶段
		beforeUpdate：在数据发生改变后,DOM被更新之前被调用。适合现有DOM将要被更新之前访问,比如移除手动添加的事件监听器
		updated：在数据更改导致的虚拟DOM重新渲染和更新完毕之后调用。避免在这个期间更改状态。不会保证所有的子组件也都被重新渲染,整个视图都渲染完毕的话,可以在 `updated` 里使用nextTick
	4. 销毁阶段
		beforeDestroy：在实例销毁之前被调用
		应用场景：解绑事件,取消定时器等。
		destroyed：实例销毁后调用,对应vue实例的所有指令都被解绑,所有的事件监听器被移除,所有的子实例也都被销毁。
	activated: 被keep-alive缓存的组件激活时调用
	deactivated: 被keep-alive缓存的组件失活时调用
### 7. vue的修饰符有哪些？⭐

### 8 . vue如何进行组件通信？ ⭐⭐⭐⭐
	1. Props/父子组件通信：
		通过在父组件中使用属性(props)来向子组件传递数据。子组件可以通过`props`选项来接收这些属性。实现单项数据流的基本方法,子组件无法直接修改父组件的属性。
	2. 自定义事件/子父组件通信：
		子组件->可以通过`$emit`方法触发自定义事件,并将需要传递的数据作为参数传递给父组件。
		父组件->可以使用v-on或@指令来监听子组件触发的事件,并在事件处理函数中获取传递的数据。
	3. Vuex/集中式状态管理：
		用于在多个组件之间共享状态,Vuex将状态集中储存在一个全局的状态树中,组件可以通过this.$store.state来访问状态,同时也可以使用mutations来修改状态。
	4. Provide/Inject
		父组件可以通过provide选项提供数据,子组件可以通过inject选项来注入这些数据。适用于祖先组件->后代组件传递数据,但是不适合在非直接父子关系的组件之间使用
	5.
### 9. keep-alive是什么？使用方式？ ⭐⭐⭐
`Keep-alive是Vue提供的内置组件，用于缓存和复用组件实例，对于频繁切换组件或在组件内有大量状态需要维护时，可以有效提升性能。`
应用场景:
1. `当一个组件被包裹在Keep-alive标签内部时，该组件的实例将被缓存，而不是每次都重新创建一个新的组件实例，这对于一些需要保持状态的组件(表单数据或滚动位置)非常有用`
### 10. vue路由怎么传参？ ⭐⭐⭐⭐

### 11. vue路由的hash模式和history模式有什么区别？ ⭐⭐⭐⭐
Hash模式
1. `以#为基础，浏览器不会向服务器发送请求，只会解释hash的变化`。
应用场景：
`适用于单页应用(SPA),不需要服务器配置。`

History模式:
1. `通过HTML5的`  `history.pushState` 和 `history.replaceState`` API,在URL发生变化时，浏览器会向服务器请求对应资源`
应用场景:
`适用于提升 SEO 的优化和需要 服务器配置 来支持URL的变化`

### 12. vue路由拦截是怎么实现的？⭐⭐⭐
**beforeEach：** `在每个路由导航之前执行。用于进行权限验证、登录状态检查等。如果未通过验证，可以跳转登录页面`。
**afterEach：** `在每个路由导航之后执行。通常用于埋点统计等操作，不会影响导航本身。``
**beforeRouteEnter：** `在进入路由之前被调用。适用于获取路由组件内部的数据，如从服务器获取数据后再进入路由。`
**beforeRouteUpdate：** `在当前路由复用时调用，如在同一路由不同参数间切换。 
**beforeRouteLeave：** `在离开当前路由之前被调用。用于显示确认提示框，或保存未提交的表单数据等。
### 13. 说一下vue的动态路由 ⭐⭐⭐⭐
	1.在路由配置里设置meta属性,拓展权限相关的字段,在路由导航守卫里通过判断这个权限标识,实现路由的动态增加和跳转
	2.在前端应用中,用户登录后,后端通常会返回用户的角色信息,前端可以根据这些角色信息来判断用户有权访问哪些路由。
	3. 前端可以通过在路由导航守卫（`beforeEach` 钩子）中进行判断，根据用户的角色和路由配置中的权限信息来决定是否允许访问某个路由。如果用户角色匹配了某个路由的权限要求，就将该路由添加到可访问的路由列表中。
	4. 在动态生成可访问路由列表后，可以通过 Vue Router 的 `router.addRoutes` 方法将这些路由添加到路由配置中，从而实现动态增加路由。
### 14. 如何解决刷新后二次加载路由 ⭐⭐⭐
`window.location.reload() // 可能会出现闪屏的问题`
**动态清除注册的路由:** 
`const router=createRouter() 
`export function resetRouter(){ `
	`const newRouter=creatRouter 
	`router.maycher=newRouter.matcher 
`}
### 15.vue刷新数据丢失如何解决？ ⭐⭐⭐
**持久化状态管理：** `将需要保留的数据存储到浏览器的本地存储（如 `localStorage` 或 `sessionStorage`）中。在刷新页面后，您可以从本地存储中读取数据并恢复状态`
**Vuex 持久化插件：** `vuex-persistedstate 来将 Vuex 的状态持久化到本地存储。这样即使刷新页面，Vuex 的状态仍然可以从本地存储中恢复``
**后端保存：** `页面刷新的时候再次请求数据,达到动态更新vuex数据`
### 16. computed和watch的区别 ⭐⭐⭐
**computed**：`计算属性主要用于计算和派生状态，将一些复杂的逻辑封装成属性，并将计算的结果在模板中展示`
1. 支持缓存：`自动追踪响应式依赖,当依赖的数据发生变化时会自动重新计算。可以避免不必要的计算，提高性能`
2. 不支持异步操作
**watch**：`用于观察特定的数据变化，并在变化时执行自定义的操作，如副作用、异步操作等`
1. 没有缓存：`watch` 不会缓存计算结果，每次响应式状态发生变化都会触发回调函数
2. 自定义操作：`可以执行自定义的函数，根据数据变化来执行一些特定的操作，如发起网络请求、处理副作用(更改DOM)等`
3. 异步操作：`适合处理需要等待异步结果的情况，例如从服务器获取数据后更新状态`
参数：
	immediate: `组件加载时立即触发`
	deep: `深度观察对象内部属性的变化`
### 17. vuex的主要应用场景以及使用方式 ⭐⭐⭐
  
Vuex 是 Vue.js 的官方状态管理库，用于管理应用程序中的共享状态。主要应用场景包括：
1. **大型应用程序：** `在大型应用中，组件之间可能需要共享许多状态（如用户信息、购物车状态等）。使用 Vuex 可以更方便地集中管理这些共享状态，避免状态分散在不同组件中导致难以维护的情况。`
2. **跨组件通信：** `如果多个组件需要共享数据或进行通信，Vuex 提供了一个集中的地方来存储和更新这些数据，使得跨组件通信更加清晰和可控。`
    
3. **异步操作：**` Vuex 也适用于处理异步操作，比如发送网络请求或操作后端数据。Vuex 中定义 actions 来触发异步操作，确保状态的变化是可追踪的`。
使用方式:
1. 安装 Vuex: `npm install vuex --save`
2. 创建 Vuex Store： `我们在项目中创建一个 Vuex store 实例，通过定义 `state`、`mutations`、`actions` 和 `getters` 等来管理应用的状态和业务逻辑`
3. 注册 Vuex Store：`在 Vue 应用的入口文件main.js中注册 Vuex。`
4. 组件内使用：`我们可以使用 `mapState`、`mapMutations`、`mapActions` 和 `mapGetters` 等辅助函数来连接 Vuex 和组件`
### 18. Vuex 的核心概念是什么？⭐
`Vuex 的核心概念是“单一状态树”和“状态管理模式”。在 Vuex 中，整个应用的状态被存储在一个单一的对象中，称为“状态树”（或“store”）。这个状态树通过 mutations 来修改，通过 actions 来触发异步操作，通过 getters 来计算派生状态。这种状态管理模式使得应用中的状态变化变得可预测和可追踪，同时也方便了多个组件之间的数据共享和通信。`
### 19. Vuex 的 mutations 和 actions 有什么区别？⭐⭐
在 Vuex 中，`mutations` 和 `actions` 都用于处理状态的变更，但它们在功能和使用情境上有一些区别。
**mutations：**`用于同步地修改状态。每个 mutation 都是一个处理函数，接收当前状态作为参数，可以在其中进行状态的修改。Mutations 应该是同步操作，用于追踪状态的变化历史。`
- commit `用于触发同步的状态变更(mutations)

**actions：**`用于处理异步操作和复杂的业务逻辑。每个 action 都是一个方法，可以在其中执行异步操作，然后通过提交 mutations 来修改状态。`
- dispatch `用于触发包含异步操作的业务逻辑(actions)
### 20. Vuex 的 getters 是什么？它有什么作用？⭐
`Vuex 的 `getters` 是用于从状态树中派生出新状态的函数。它们类似于组件中的计算属性，但是在 Vuex 中定义，可以在多个组件中共享和复用。`getters` 可以用于对状态进行一些计算、过滤或转换操作，然后供组件使用，从而减少冗余的计算和提高性能`。
### 21. vue的响应式原理是什么？⭐⭐⭐
**Vue2.x**`中是通过数据劫持和发布订阅者模式来实现的,同时利用Object.defineProperty()劫持各个属性的setter和getter,在数据发生改变时发布消息给订阅者,触发对应的监听回调渲染视图。``
**步骤：**
1. `需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter
2. `compile模板解析指令,把模板中的变量替换成数据,然后初始化渲染视图,同时把每个指令对应的节点绑定更新函数,当数据发生变化时,渲染函数能够重新执行并更新视图。`
3. `Watcher订阅者是Observer和Compile之间的通信桥梁,每个表达式或指令在模板中都有一个对应的 Watcher，它负责在数据变化时更新视图。当数据被修改时，会通知相关的 Watcher，然后 Watcher 触发重新渲染。
**Vue3**`使用了Js中的 Proxy 对象来实现响应式。Proxy 可以拦截对象的操作，包括属性的读取、赋值、删除等操作,从而实现对数据的劫持和观察。完善了definePropery 的缺陷，如监听属性的删除。还可以代理更丰富的数据结构,比如 Map、Set`
### 22. vue的双向数据绑定是什么 ⭐⭐⭐
`Vue 的双向数据绑定是一种机制，允许数据和视图之间实现双向的自动同步。在 Vue 中，我们可以使用 `v-model` 指令来将表单元素的值与 Vue 实例中的数据属性关联起来。也可以说是一个input事件和value的语法糖。
**另一种在组件内实现 v-model的方式：**`是通过创建一个可写的计算属性，同时定义 getter 和 setter。这个计算属性充当了数据的中间层，使我们能够在组件内部对传入的数据进行一些自定义处理和逻辑。在这个计算属性的 getter 中，我们返回了外部传入的 `modelValue` prop 的值，确保初始时和外部数据同步。而在 setter 中，我们通过使用 `$emit` 方法来触发一个特定事件，通常命名为 `update:modelValue`，从而实现了对 `v-model` 的更新。这个事件会将新的值传递给父组件，让父组件的数据也得到更新。
### 23. 了解diff算法和虚拟DOM吗？ ⭐⭐⭐⭐
**虚拟 DOM（Virtual DOM）：** `虚拟 DOM 是一种用 JavaScript 对象表示真实 DOM 结构的技术。它允许框架在更新视图时，先在虚拟 DOM 上进行操作，然后通过比较新旧虚拟 DOM 的差异来最小化对真实 DOM 的操作。这样可以提高性能，因为操作虚拟 DOM 的成本要比操作真实 DOM 低得多。Vue 和 React 都使用了虚拟 DOM 来优化视图更新。`

**Diff 算法：** `Diff 算法是用于比较两个树结构的算法，常用于比较虚拟 DOM 和确定最小化的 DOM 更新。当数据发生变化时，Diff 算法会比较新旧虚拟 DOM 树，找出差异，然后在真实 DOM 中应用这些差异。Diff 算法的目标是尽量减少 DOM 操作的数量，从而提高性能。`

**Diff 算法的基本思想是：**
`1. 比较两棵树的根节点，如果不同，则替换根节点及其子树。
`2. 对比新旧节点的类型，如果类型不同，则替换节点。`
`3. 对比节点的属性和内容，更新有变化的部分。`
`4. 递归比较子节点，找出子节点之间的差异。`
`通过这种方式，Diff 算法可以高效地确定需要更新的部分，从而最小化了 DOM 操作的开销``
### 24. 什么情况下使用$set?
`由于vue在初始化实例时进行双向数据绑定,使用Object.definedProperty()对属性遍历添加setter,getter方法,所有属性必须在data对象上存在时才能进行上述流程,这样的数据才是响应式的。
*动态添加属性:* `当需要向一个已经创建的响应式对象中动态添加一个新的属性时，使用 $set 可以确保新属性也是响应式的,并且会触发视图更新`
`1. 响应式对象添加新属性
`this.$set(this.someObject, 'newProperty', 'value');`
*处理数组元素变化:* `在处理数组时，Vue 无法检测到索引的变化，即使通过索引修改数组中的值，视图可能不会更新。
`1. 利用索引直接设置一个数组项时
`this.$set(this.someArray, 0, 'newValue');
### 25. vue中，数组的push和pop方法反而可以监听到？
`在 Vue 中，通过普通的 `push` 和 `pop` 方法向数组添加或删除元素是可以被监听到的，从而触发视图的更新。这是因为 Vue 通过改写数组的原型方法，使得这些方法在执行时会自动调用 Vue 的响应式更新机制
`push pop unshift shift sort reserve splice`
### 26. 未登录路由挂载问题
`在 Vue.js 应用中，当用户访问需要登录的页面时，我们需要确保用户已经登录，否则就需要将用户重定向到登录页面或其他公开页面。为了实现这个功能，我们可以借助 Vue Router 提供的路由守卫机制。
`1. 可以通过 beforeEach 钩子函数拦截路由导航，然后检查用户的登录状态。如果用户未登录而访问了需要登录的页面，我们可以使用 next('/login') 来进行重定向，确保用户进行登录后才能访问受限页面。
`2. 同时还可以在路由配置中使用 meta 字段来标记需要登录的页面，以便在路由守卫中更方便地判断页面是否需要登录
### 27. vue 父组件和父子件创建和挂载顺序
*创建过程⾃上⽽下，挂载过程⾃下⽽上*
		`1. 父beforeCreate-->父created-->父beforeMount
		`2. 子beforeCreate-->子created-->子beforeMount
		`3. 子mouted-->父mounted